<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>شجرة العائلة التفاعلية</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Noto+Sans+Arabic:wght@400;600;700&display=swap" rel="stylesheet">
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.min.js"></script>
    <style>
        /* Basic Reset & Body Styling */
        body {
            font-family: 'Noto Sans Arabic', 'Inter', sans-serif;
            background-color: #f0f2f5;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            direction: rtl;
            text-align: right;
            color: #333;
            overflow-x: hidden; /* Prevent body horizontal scroll */
            overflow-y: auto;
        }

        /* Header Styling - Mimicking OSINT Framework */
        #header {
            width: 100%;
            background-color: #333;
            color: #fff;
            padding: 15px 0;
            text-align: center;
            font-size: 1.8em;
            font-weight: 700;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        #header hr {
            border: none;
            border-top: 1px solid #555;
            margin: 10px auto 0;
            width: 80%;
        }

        /* Main content area for the tree */
        #tree-container {
            flex-grow: 1;
            width: 100%;
            max-width: 100%;
            background-color: #ffffff;
            border-radius: 0 0 12px 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            margin-top: 20px;
            margin-right: 20px;
            padding: 0px; /* Padding for the container */
            box-sizing: border-box;
            overflow: auto; /* Allow scrolling for the tree itself */
            display: flex;
            justify-content: center; /* Center SVG content initially */
            align-items: flex-start; /* Align SVG content to top */
            min-height: 400px;
        }

        /* SVG styling for D3 tree */
        .node circle {
            fill: #e8f0fe;
            stroke: #cce0ff;
            stroke-width: 1.5px;
            cursor: pointer;
        }

        .node text {
            font-size: 0.9em;
            font-weight: 600;
            fill: #333;
            pointer-events: none;
            direction: rtl; /* Important for Arabic text */
            unicode-bidi: embed; /* Handle complex bidirectional text */
        }

        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 1.5px;
        }

        /* Notes and Footer Styling */
        .notes-section {
            width: 80%;
            max-width: 800px;
            margin: 30px auto;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            box-sizing: border-box;
            text-align: right;
        }

        .notes-section h3 {
            color: #4a90e2;
            margin-top: 0;
            font-size: 1.4em;
        }

        .notes-section p {
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .notes-section a {
            color: #4a90e2;
            text-decoration: none;
        }

        .notes-section a:hover {
            text-decoration: underline;
        }

        /* Footer Styling */
        .footer-section {
            width: 100%;
            padding: 20px;
            margin-top: 30px;
            background-color: #333;
            color: #f0f2f5;
            text-align: center;
            font-size: 0.9em;
            box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.1);
        }

        .footer-section a {
            color: #7bbaff;
            text-decoration: none;
            font-weight: 600;
        }

        .footer-section a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div id="header">
        شجرة عائلة آل حنين
        <hr/>
    </div>
    
    <div id="tree-container">
    </div>

    <div class="notes-section">
        <h3>ملاحظات</h3>
        <p>
            يُرجى العلم بأن هذه الشجرة ليست مكتملة بعد، وسيتم العمل على إكمالها.
        </p>
        
    </div>

    <footer class="footer-section">
        <p>&copy; 2025 شجرة العائلة التفاعلية. جميع الحقوق محفوظة. تم إنشاؤها بواسطة
        <a href="#" class="internal-node-link" data-target-node="منصور عبده علي حنين">منصور عبده علي حنين</a>.</p>
    </footer>
    <script>
        // Define the family tree data structure
        const familyData = {
            name: "شوعي احمد حنين",
            children: [
                {
                    name: "علي",
                    children: [
                        {
                            name: "عباس",
                            children: [
                                { 
                                    name: "علي",
                                    children: [
                                        { name: "هتان" }
                                    ]
                                },
                                { name: "عبد الرحمن" },
                                { name: "احمد" },
                                { name: "شروق" },
                                { name: "نجود" }
                            ]
                        },
                        {
                            name: "عبده",
                            children: [
                                { 
                                    name: "علي",
                                    children: [
                                        { name: "اليزيد" },
                                        { name: "الوليد" },
                                        { name: "منصور" }
                                    ]
                                },
                                { name: "منصور" }, 
                                { name: "رقية" },
                                { name: "فجر" },
                                { name: "جنى" },
                                { name: "بدر" },
                                { name: "بندر" }
                            ]
                        },
                        {
                            name: "محمد",
                            children: [
                                { name: "فراس" },
                                { name: "حمزة" }, 
                                { name: "سارة" },
                                { name: "يارا" }
                            ]
                        },
                        {
                            name: "منصور",
                            children: [
                                { name: "رناس" },
                                { name: "عبد الرحمن" }
                            ]
                        },
                        { name: "نعمه" },
                        { name: "ريم" }
                    ]
                },
                { name: "عباس" },
                { name: "حليمة" },
                { name: "فاطمة" },
                { name: "عيشة" },
                { name: "كنان" }
            ]
        };

        let i = 0; // Global node counter for unique IDs
        let duration = 750; // Animation duration

        let tree, diagonal, svg, root; // Declare globally
        let currentMargin = { top: 60, right: 0, bottom: 60, left: 0 }; // Global variable to store calculated margins
        const textRotationAngle = -35; 

        // Function to initialize or re-initialize D3 elements based on container size
        function initializeD3() {
            const container = document.getElementById('tree-container');
            const screenWidth = window.innerWidth;

            // Define dynamic margins based on screen width
            // These margins are *inside* the SVG, not the tree-container
            if (screenWidth > 1200) { // Large screens (desktops)
                currentMargin.right = 160;
                currentMargin.left = 160;
            } else if (screenWidth > 768) { // Medium screens (tablets)
                currentMargin.right = 80;
                currentMargin.left = 80;
            } else { // Small screens (phones)
                currentMargin.right = 20; 
                currentMargin.left = 20;  
            }

            // Use clientWidth and clientHeight for the actual visible area of the tree-container
            // We subtract the internal SVG margins from the container's available space
            let availableWidthForLayout = container.clientWidth - currentMargin.left - currentMargin.right;
            let availableHeightForLayout = container.clientHeight - currentMargin.top - currentMargin.bottom;

            // Ensure minimum dimensions for the D3 layout to prevent collapse
            availableWidthForLayout = Math.max(availableWidthForLayout, 400); 
            availableHeightForLayout = Math.max(availableHeightForLayout, 400); 

            // Clear any existing SVG to prevent duplicates on resize
            d3.select("#tree-container svg").remove();

            // Create a tree layout
            tree = d3.layout.tree()
                // .size([width, height]) sets the dimensions of the rectangular space
                // that the tree layout will attempt to fit the nodes into.
                .size([availableWidthForLayout, availableHeightForLayout]); 

            // Create a diagonal path generator for links
            diagonal = d3.svg.diagonal()
                .projection(function(d) { return [d.x, d.y]; });

            // Select the container and append SVG
            svg = d3.select("#tree-container").append("svg")
                // The SVG element itself should encompass the layout size PLUS the margins
                .attr("width", availableWidthForLayout + currentMargin.left + currentMargin.right) 
                .attr("height", availableHeightForLayout + currentMargin.top + currentMargin.bottom) 
                .append("g")
                // Translate the main 'g' element to account for the top/left margins
                .attr("transform", "translate(" + currentMargin.left + "," + currentMargin.top + ")");
            
            // Only assign root once on the very first load
            if (!root) { 
                root = familyData;
                // Initial x0 and y0 should be relative to the *tree layout's* coordinate system
                // which is 0 to `availableWidthForLayout` and 0 to `availableHeightForLayout`.
                root.x0 = availableWidthForLayout / 2; // Initial x position for root (centered horizontally in layout space)
                root.y0 = 0; // Initial y position for root (top of layout space)

                // Collapse all children initially except the first level
                function collapse(d) {
                    if (d.children) {
                        d._children = d.children;
                        d._children.forEach(collapse);
                        d.children = null;
                    }
                }
                // Collapse all nodes except the root and its direct children
                if (root.children) {
                    root.children.forEach(collapse);
                }
            }
            
            // Update the tree to reflect new dimensions or initial draw
            update(root); 
        }

        // Helper to find a node by name and expand its path
        function findNodeAndExpandPath(startNode, targetName) {
            let foundNode = null;

            function searchAndExpand(node) {
                if (!node) return false;

                if (node.name === targetName) {
                    foundNode = node;
                    return true;
                }

                if (node._children) {
                    node.children = node._children;
                    node._children = null;
                }

                if (node.children) {
                    for (let i = 0; i < node.children.length; i++) {
                        if (searchAndExpand(node.children[i])) {
                            return true; 
                        }
                    }
                }
                if (foundNode === null && node.children) { 
                    node._children = node.children;
                    node.children = null;
                }
                return false;
            }

            function collapseAll(node) {
                if (node.children) {
                    node._children = node.children;
                    node._children.forEach(collapseAll);
                    node.children = null;
                }
            }
            if (startNode.children) { 
                startNode.children.forEach(collapseAll);
            }

            searchAndExpand(startNode);
            return foundNode;
        }

        // Function to scroll to a specific node
        function scrollToNode(nodeElementId) {
            const targetG = d3.select("#" + nodeElementId);
            if (targetG.empty()) {
                console.warn("Target node element not found:", nodeElementId);
                return;
            }

            const treeContainer = document.getElementById('tree-container');
            const nodeData = targetG.datum(); 
            
            // Get the calculated translationX from the last update
            // This is crucial because nodeData.x is relative to D3's internal layout space (0 to layoutWidth)
            // but the actual SVG position is shifted by translationX.
            let nodes = tree.nodes(root); // Recalculate nodes to get fresh x positions
            let minX = d3.min(nodes, d => d.x);
            let maxX = d3.max(nodes, d => d.x);
            let treeContentWidth = maxX - minX;
            const availableLayoutWidth = tree.size()[0]; // Width used for D3 layout
            let translationX = (availableLayoutWidth / 2) - (treeContentWidth / 2) - minX;

            // Calculate the node's position relative to the SVG's top-left origin (0,0)
            // This includes the layout's calculated X, the horizontal centering offset, AND the SVG's left margin
            const nodeAbsX_in_svg = nodeData.x + translationX + currentMargin.left;
            const nodeAbsY_in_svg = nodeData.y + currentMargin.top; // Y is simpler as there's no dynamic vertical centering

            // Calculate scroll position to center the node in the container
            const scrollX = nodeAbsX_in_svg - (treeContainer.clientWidth / 2);
            const scrollY = nodeAbsY_in_svg - (treeContainer.clientHeight / 2);

            treeContainer.scrollTo({
                left: scrollX,
                top: scrollY,
                behavior: 'smooth'
            });
        }


        // Function to update the tree
        function update(source) {
            // Compute the new tree layout.
            const nodes = tree.nodes(root); 
            const links = tree.links(nodes);

            // Normalize for fixed-depth (vertical spacing).
            const depthSpacing = 120; // Increased from 100 to 120. Adjust as needed.
            nodes.forEach(function(d) { d.y = d.depth * depthSpacing; });

            // Calculate the extent of the tree's x-coordinates to center it
            // This needs to be done *after* tree.nodes(root) to get the latest x values
            let minX = d3.min(nodes, d => d.x);
            let maxX = d3.max(nodes, d => d.x);
            
            // Calculate the actual width of the tree content (from leftmost to rightmost node)
            let treeContentWidth = maxX - minX;

            // Get the available width that the D3 tree layout is using
            const availableLayoutWidth = tree.size()[0]; 

            // Calculate translation needed to center the tree content horizontally within the availableLayoutWidth
            // This offset is applied to each node's x-position.
            let translationX = (availableLayoutWidth / 2) - (treeContentWidth / 2) - minX;
            
            // Update the nodes…
            const node = svg.selectAll("g.node")
                .data(nodes, function(d) { return d.id || (d.id = ++i); });

            // Enter any new nodes at the parent's previous position.
            const nodeEnter = node.enter().append("g")
                .attr("class", "node")
                .attr("id", function(d) { return "node-" + d.id; })
                .attr("transform", function(d) {
                    // Initial position for new nodes, using source's (x0, y0) and applying the horizontal translationX
                    return "translate(" + (source.x0 + translationX) + "," + source.y0 + ")"; 
                })
                .on("click", click);

            nodeEnter.append("circle")
                .attr("r", 1e-6)
                .style("fill", function(d) { return d._children ? "#e8f0fe" : "#fff"; });

            nodeEnter.append("text")
                .attr("y", function(d) {
                    // Adjust y-offset for text based on if it has children (collapsed or expanded)
                    d.textYOffset = d.children || d._children ? -18 : 18;
                    return d.textYOffset;
                })
                .attr("dy", ".35em")
                .attr("text-anchor", "middle") 
                .attr("transform", function(d) {
                    return "rotate(" + textRotationAngle + ", 0, " + d.textYOffset + ")"; 
                })
                .text(function(d) { return d.name; })
                .style("fill-opacity", 1e-6);

            // Transition nodes to their new position.
            const nodeUpdate = node.transition()
                .duration(duration)
                .attr("transform", function(d) { 
                    // Apply horizontal centering offset here as well
                    return "translate(" + (d.x + translationX) + "," + d.y + ")"; 
                });

            nodeUpdate.select("circle")
                .attr("r", 8)
                .style("fill", function(d) { return d._children ? "#e8f0fe" : "#fff"; });

            nodeUpdate.select("text")
                .attr("y", function(d) { 
                    d.textYOffset = d.children || d._children ? -18 : 18;
                    return d.textYOffset;
                })
                .style("fill-opacity", 1)
                .attr("transform", function(d) {
                    return "rotate(" + textRotationAngle + ", 0, " + d.textYOffset + ")"; 
                });

            // Transition exiting nodes to the parent's new position.
            const nodeExit = node.exit().transition()
                .duration(duration)
                .attr("transform", function(d) { 
                    return "translate(" + (source.x + translationX) + "," + source.y + ")"; 
                })
                .remove();

            nodeExit.select("circle")
                .attr("r", 1e-6);

            nodeExit.select("text")
                .style("fill-opacity", 1e-6);

            // Update the links…
            const link = svg.selectAll("path.link")
                .data(links, function(d) { return d.target.id; });

            // Enter any new links at the parent's previous position.
            link.enter().insert("path", "g")
                .attr("class", "link")
                .attr("d", function(d) {
                    // Links start from the source's previous position, with translationX applied
                    const o = { x: source.x0 + translationX, y: source.y0 }; 
                    return diagonal({ source: o, target: o });
                });

            // Transition links to their new position.
            link.transition()
                .duration(duration)
                .attr("d", function(d) {
                    // Links go to their new positions, with translationX applied
                    const s = { x: d.source.x + translationX, y: d.source.y };
                    const t = { x: d.target.x + translationX, y: d.target.y };
                    return diagonal({ source: s, target: t });
                });

            // Transition exiting links to the parent's new position.
            link.exit().transition()
                .duration(duration)
                .attr("d", function(d) {
                    // Exiting links animate towards the source's current position, with translationX applied
                    const o = { x: source.x + translationX, y: source.y };
                    return diagonal({ source: o, target: o });
                })
                .remove();

            // Stash the old positions for transition.
            nodes.forEach(function(d) {
                d.x0 = d.x + translationX; // Store adjusted x for transitions
                d.y0 = d.y;
            });

            // After the update, adjust the SVG's actual width if the tree content is wider than the container.
            // This helps with ensuring scrollability if the content overflows.
            const container = document.getElementById('tree-container');
            const requiredSVGWidth = (maxX - minX) + (currentMargin.left + currentMargin.right);
            const currentSVGWidth = parseFloat(d3.select("#tree-container svg").attr("width"));

            // Set the SVG's width to be at least the required width, or the container's max width if it's smaller
            const newSVGWidth = Math.max(requiredSVGWidth, container.clientWidth); 
            d3.select("#tree-container svg").attr("width", newSVGWidth);

            // Also ensure SVG height accommodates the deepest node
            let maxY = d3.max(nodes, d => d.y);
            const requiredSVGHeight = maxY + currentMargin.top + currentMargin.bottom + 50; // Add some extra buffer
            const currentSVGHeight = parseFloat(d3.select("#tree-container svg").attr("height"));
            const newSVGHeight = Math.max(requiredSVGHeight, container.clientHeight);
            d3.select("#tree-container svg").attr("height", newSVGHeight);
        }

        // Toggle children on click.
        function click(d) {
            if (d.children) {
                d._children = d.children;
                d.children = null;
            } else {
                d.children = d._children;
                d._children = null;
            }
            update(d);
        }

        // Initialize the tree on page load
        window.onload = function() {
            initializeD3(); 

            // Attach event listener for the footer link
            document.querySelector('.internal-node-link').addEventListener('click', function(e) {
                e.preventDefault();
                const targetNodeName = this.dataset.targetNode; 
                
                const targetNode = findNodeAndExpandPath(root, targetNodeName);

                if (targetNode) {
                    update(root); 

                    setTimeout(() => {
                        scrollToNode("node-" + targetNode.id);
                    }, duration + 50);
                } else {
                    console.warn("Node '" + targetNodeName + "' not found in the tree data.");
                }
            });
        };

        // Resize function to make the SVG responsive
        window.addEventListener('resize', () => {
            initializeD3(); 
        });
    </script>
</body>
</html>
